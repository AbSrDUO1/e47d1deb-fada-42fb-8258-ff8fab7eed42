import type { Metadata } from "next";
import { Inter_Tight, Playfair_Display } from "next/font/google";
import "./globals.css";

const interTight = Inter_Tight({
  variable: "--font-inter-tight",
  subsets: ["latin"],
  weight: ["100", "200", "300", "400", "500", "600", "700", "800", "900"],
});

const playfairDisplay = Playfair_Display({
  variable: "--font-playfair",
  subsets: ["latin"],
  weight: ["400", "500", "600", "700", "800", "900"],
});

export const metadata: Metadata = {
  title: "Mvpblocks",
  description: "Create a minimal, single-page SaaS landing for a playful Chess platform with a 3D-friendly buy flow and clear conversion"
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body className={`${interTight.variable} ${playfairDisplay.variable} antialiased`}>
        {children}
      
        {/* Visual Editor Script - Only runs in iframe */}
        <script
          dangerouslySetInnerHTML={{
            __html: "\n(function() {\n  // Only run in iframe context\n  if (window.self === window.top) return;\n  \n  // Check if already initialized\n  if (window.__webildEditorInitialized) return;\n  window.__webildEditorInitialized = true;\n\n  console.log('[Webild Visual Editor] Script loaded, waiting for activation...');\n\n  let isActive = false;\n  let hoveredElement = null;\n  let selectedElement = null;\n  let originalContent = null;\n  let isEditing = false;\n\n  // Track actual changes made by the user\n  const actualChanges = [];\n  let listenersAttached = false;\n\n  const textElements = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'p', 'span', 'a', 'button', 'li', 'div'];\n  const invalidElements = ['html', 'body', 'script', 'style', 'meta', 'link', 'head'];\n  const hoverClass = 'webild-hover';\n  const selectedClass = 'webild-selected';\n\n  // Add styles\n  const style = document.createElement('style');\n  style.id = 'webild-inspector-styles';\n  style.textContent = `\n    .webild-hover {\n      outline: 2px dashed rgba(109, 51, 252, 0.6) !important;\n      outline-offset: 2px !important;\n      cursor: pointer !important;\n    }\n    .webild-selected {\n      outline: 2px solid rgba(109, 51, 252, 0.9) !important;\n      outline-offset: 2px !important;\n    }\n    [contenteditable=\"true\"].webild-selected {\n      outline: 2px solid rgba(59, 130, 246, 0.9) !important;\n      background-color: rgba(59, 130, 246, 0.05) !important;\n    }\n  `;\n  document.head.appendChild(style);\n\n  const getUniqueSelector = (element) => {\n    const path = [];\n    let current = element;\n    \n    while (current && current !== document.body) {\n      let selector = current.tagName.toLowerCase();\n      \n      if (current.id) {\n        selector = `#${current.id}`;\n        path.unshift(selector);\n        break;\n      }\n      \n      const parent = current.parentElement;\n      if (parent) {\n        const siblings = Array.from(parent.children).filter(el => el.tagName === current.tagName);\n        if (siblings.length > 1) {\n          const index = siblings.indexOf(current) + 1;\n          selector += `:nth-of-type(${index})`;\n        }\n      }\n      \n      path.unshift(selector);\n      current = parent;\n      \n      if (path.length >= 3) break;\n    }\n    \n    return path.join(' > ');\n  };\n  \n  const getElementInfo = (element) => {\n    const rect = element.getBoundingClientRect();\n    const tagName = element.tagName.toLowerCase();\n    \n    const selector = getUniqueSelector(element);\n    \n    const info = {\n      tagName: tagName,\n      id: element.id || undefined,\n      className: element.className || undefined,\n      selector: selector,\n      boundingBox: {\n        x: rect.left,\n        y: rect.top,\n        width: rect.width,\n        height: rect.height\n      }\n    };\n    \n    if (tagName === 'img') {\n      info.imageData = {\n        src: element.src,\n        alt: element.alt || undefined,\n        naturalWidth: element.naturalWidth,\n        naturalHeight: element.naturalHeight\n      };\n    }\n    \n    const computedStyle = window.getComputedStyle(element);\n    const backgroundImage = computedStyle.backgroundImage;\n    if (backgroundImage && backgroundImage !== 'none') {\n      const urlMatch = backgroundImage.match(/url\\(['\"]?([^'\")]+)['\"]?\\)/);\n      if (urlMatch) {\n        info.imageData = {\n          src: urlMatch[1],\n          isBackground: true\n        };\n      }\n    }\n    \n    return info;\n  };\n\n  const isValidElement = (element) => {\n    const tagName = element.tagName?.toLowerCase();\n    return !invalidElements.includes(tagName);\n  };\n\n  const isTextElement = (element) => {\n    const tagName = element.tagName.toLowerCase();\n    if (!textElements.includes(tagName)) return false;\n    \n    if (tagName === 'div') {\n      const hasElementChildren = Array.from(element.children).length > 0;\n      if (hasElementChildren) return false;\n    }\n    \n    return true;\n  };\n\n  const makeEditable = (element, clickEvent) => {\n    if (!isTextElement(element)) return;\n\n    // Store original text content if not already stored\n    if (!element.dataset.webildOriginalText) {\n      element.dataset.webildOriginalText = element.textContent;\n    }\n\n    originalContent = element.dataset.webildOriginalText;\n\n    // For elements with text animation (character divs), replace with plain text for editing\n    const hasCharDivs = element.querySelector('.slide-char, .fade-char, .bounce-char');\n    if (hasCharDivs) {\n      element.innerHTML = originalContent;\n    }\n\n    element.contentEditable = 'true';\n    element.focus();\n    isEditing = true;\n    \n    window.parent.postMessage({\n      type: 'webild-text-editing-started',\n      data: { selector: getElementInfo(element).selector }\n    }, '*');\n    \n    const handleInput = () => {\n      if (element.textContent !== originalContent) {\n        window.parent.postMessage({\n          type: 'webild-text-changed',\n          data: { \n            selector: getElementInfo(element).selector,\n            hasChanges: true\n          }\n        }, '*');\n      }\n    };\n    \n    element.addEventListener('input', handleInput);\n    element.dataset.inputHandler = 'true';\n    \n    if (clickEvent && element.childNodes.length > 0) {\n      const range = document.caretRangeFromPoint(clickEvent.clientX, clickEvent.clientY);\n      if (range) {\n        const selection = window.getSelection();\n        selection.removeAllRanges();\n        selection.addRange(range);\n      }\n    }\n  };\n\n  const makeUneditable = (element, save = false) => {\n    if (!element || element.contentEditable !== 'true') return;\n    \n    element.contentEditable = 'false';\n    isEditing = false;\n    \n    if (element.dataset.inputHandler === 'true') {\n      element.removeEventListener('input', () => {});\n      delete element.dataset.inputHandler;\n    }\n    \n    window.parent.postMessage({\n      type: 'webild-text-editing-ended',\n      data: { selector: getElementInfo(element).selector }\n    }, '*');\n    \n    const newText = element.textContent;\n\n    if (save && originalContent !== newText) {\n      // Update the stored original text\n      element.dataset.webildOriginalText = newText;\n\n      // Track this change\n      const changeData = {\n        selector: getElementInfo(element).selector,\n        type: 'text',\n        oldValue: originalContent,\n        newValue: newText,\n        tagName: element.tagName.toLowerCase()\n      };\n\n      // Add to actualChanges array\n      actualChanges.push(changeData);\n\n      window.parent.postMessage({\n        type: 'webild-element-changed',\n        data: {\n          type: 'updateText',\n          selector: getElementInfo(element).selector,\n          oldValue: originalContent,\n          newValue: newText\n        }\n      }, '*');\n\n      // Note: The text animation will be re-applied on page reload after deployment\n    } else if (!save && originalContent !== null) {\n      // Restore original text\n      element.textContent = originalContent;\n    }\n\n    originalContent = null;\n  };\n\n  let hoverOverlay = null;\n\n  const createHoverOverlay = (element) => {\n    const rect = element.getBoundingClientRect();\n    const overlay = document.createElement('div');\n    overlay.className = 'webild-hover-overlay';\n    overlay.style.cssText = `\n      position: fixed !important;\n      top: ${rect.top - 2}px !important;\n      left: ${rect.left - 2}px !important;\n      width: ${rect.width + 4}px !important;\n      height: ${rect.height + 4}px !important;\n      background-color: rgba(109, 51, 252, 0.25) !important;\n      border-radius: 3px !important;\n      pointer-events: none !important;\n      z-index: 999998 !important;\n    `;\n    document.body.appendChild(overlay);\n    return overlay;\n  };\n\n  const removeHoverOverlay = () => {\n    if (hoverOverlay) {\n      hoverOverlay.remove();\n      hoverOverlay = null;\n    }\n  };\n\n  const handleMouseOver = (e) => {\n    if (!isActive) return;\n    \n    const target = e.target;\n    \n    if (!isValidElement(target) || target === hoveredElement || target === selectedElement) {\n      return;\n    }\n    \n    if (hoveredElement && hoveredElement !== selectedElement) {\n      hoveredElement.classList.remove(hoverClass);\n      if (hoveredElement.dataset.webildOriginalPosition) {\n        hoveredElement.style.position = hoveredElement.dataset.webildOriginalPosition === 'none' ? '' : hoveredElement.dataset.webildOriginalPosition;\n        delete hoveredElement.dataset.webildOriginalPosition;\n      }\n      removeHoverOverlay();\n    }\n    \n    hoveredElement = target;\n    \n    const computedStyle = window.getComputedStyle(target);\n    const currentPosition = computedStyle.position;\n    \n    if (currentPosition === 'static' || currentPosition === '') {\n      hoveredElement.dataset.webildOriginalPosition = currentPosition || 'none';\n      hoveredElement.style.position = 'relative';\n    }\n    \n    hoveredElement.classList.add(hoverClass);\n    \n    if ((!selectedElement || selectedElement !== target) && !isScrolling) {\n      hoverOverlay = createHoverOverlay(target);\n    }\n    \n    window.parent.postMessage({\n      type: 'webild-element-hover',\n      data: getElementInfo(target)\n    }, '*');\n  };\n\n  const handleMouseOut = (e) => {\n    if (hoveredElement && hoveredElement !== selectedElement) {\n      hoveredElement.classList.remove(hoverClass);\n      \n      if (hoveredElement.dataset.webildOriginalPosition) {\n        hoveredElement.style.position = hoveredElement.dataset.webildOriginalPosition === 'none' ? '' : hoveredElement.dataset.webildOriginalPosition;\n        delete hoveredElement.dataset.webildOriginalPosition;\n      }\n      \n      removeHoverOverlay();\n      \n      hoveredElement = null;\n      \n      window.parent.postMessage({\n        type: 'webild-element-hover',\n        data: null\n      }, '*');\n    }\n  };\n\n  const handleClick = (e) => {\n    if (!isActive) return;\n    \n    if (isEditing) {\n      e.stopPropagation();\n      return;\n    }\n    \n    e.preventDefault();\n    e.stopPropagation();\n    \n    const target = e.target;\n    \n    if (!isValidElement(target)) return;\n    \n    if (selectedElement && selectedElement !== target) {\n      makeUneditable(selectedElement, false);\n      selectedElement.classList.remove(selectedClass);\n      selectedElement.classList.remove(hoverClass);\n      \n      if (selectedElement.dataset.webildOriginalPosition) {\n        selectedElement.style.position = selectedElement.dataset.webildOriginalPosition === 'none' ? '' : selectedElement.dataset.webildOriginalPosition;\n        delete selectedElement.dataset.webildOriginalPosition;\n      }\n      \n      removeHoverOverlay();\n    }\n    \n    if (selectedElement === target) {\n      if (target.dataset.webildOriginalPosition) {\n        target.style.position = target.dataset.webildOriginalPosition === 'none' ? '' : target.dataset.webildOriginalPosition;\n        delete target.dataset.webildOriginalPosition;\n      }\n      \n      removeHoverOverlay();\n      \n      selectedElement = null;\n      window.parent.postMessage({\n        type: 'webild-element-selected',\n        data: null\n      }, '*');\n      return;\n    }\n    \n    selectedElement = target;\n    selectedElement.classList.add(selectedClass);\n    \n    removeHoverOverlay();\n    \n    if (hoveredElement === target) {\n      hoveredElement.classList.remove(hoverClass);\n      hoveredElement = null;\n    }\n    \n    window.parent.postMessage({\n      type: 'webild-element-selected',\n      data: getElementInfo(target)\n    }, '*');\n    \n    if (isTextElement(target)) {\n      setTimeout(() => makeEditable(target, e), 50);\n    }\n  };\n\n  const handleKeyDown = (e) => {\n    if (!isEditing || !selectedElement) return;\n    \n    if (e.key === 'Enter' && !e.shiftKey) {\n      e.preventDefault();\n      makeUneditable(selectedElement, true);\n    } else if (e.key === 'Escape') {\n      e.preventDefault();\n      makeUneditable(selectedElement, false);\n    }\n  };\n\n  const handleBlur = (e) => {\n    if (isEditing && selectedElement && e.target === selectedElement) {\n      makeUneditable(selectedElement, true);\n    }\n  };\n\n  let scrollTimeout = null;\n  let isScrolling = false;\n  \n  const handleScroll = () => {\n    removeHoverOverlay();\n    isScrolling = true;\n    \n    if (scrollTimeout) {\n      clearTimeout(scrollTimeout);\n    }\n    \n    scrollTimeout = setTimeout(() => {\n      isScrolling = false;\n      if (hoveredElement && (!selectedElement || selectedElement !== hoveredElement)) {\n        hoverOverlay = createHoverOverlay(hoveredElement);\n      }\n    }, 150);\n    \n    window.parent.postMessage({\n      type: 'webild-iframe-scroll'\n    }, '*');\n  };\n\n  const handleMessage = (e) => {\n    if (!e.data || !e.data.type) return;\n\n    if (e.data.type === 'webild-activate-editor') {\n      if (!isActive) {\n        isActive = true;\n        console.log('[Webild Visual Editor] Activated');\n        window.parent.postMessage({ type: 'webild-editor-activated' }, '*');\n      }\n      return;\n    }\n\n    if (e.data.type === 'webild-deactivate-editor') {\n      if (isActive) {\n        isActive = false;\n        // Clean up any active editing state\n        if (selectedElement) {\n          makeUneditable(selectedElement, false);\n          selectedElement.classList.remove(selectedClass);\n          selectedElement = null;\n        }\n        if (hoveredElement) {\n          hoveredElement.classList.remove(hoverClass);\n          hoveredElement = null;\n        }\n        removeHoverOverlay();\n        console.log('[Webild Visual Editor] Deactivated');\n        window.parent.postMessage({ type: 'webild-editor-deactivated' }, '*');\n      }\n      return;\n    }\n\n    if (e.data.type === 'webild-get-changes') {\n      // Return only the actual changes made by the user\n      console.log('[Webild Visual Editor] Sending', actualChanges.length, 'actual changes');\n\n      window.parent.postMessage({\n        type: 'webild-changes-data',\n        data: [...actualChanges] // Send a copy\n      }, '*');\n\n      // Clear the changes after sending (they'll be deployed)\n      actualChanges.length = 0;\n      return;\n    }\n\n    if (e.data.type === 'webild-apply-changes') {\n      // Apply saved changes to the page\n      const changes = e.data.data;\n      if (!changes || !Array.isArray(changes)) return;\n\n      console.log('[Webild Visual Editor] Applying', changes.length, 'saved changes');\n\n      changes.forEach(change => {\n        try {\n          const element = document.querySelector(change.selector);\n          if (!element) return;\n\n          if (change.type === 'text' && change.content !== undefined) {\n            element.textContent = change.content;\n          } else if (change.type === 'image' && change.src) {\n            if (element.tagName === 'IMG') {\n              element.src = change.src;\n              if (change.alt !== undefined) {\n                element.alt = change.alt;\n              }\n            }\n          } else if (change.type === 'backgroundImage' && change.src) {\n            element.style.backgroundImage = `url('${change.src}')`;\n          }\n        } catch (err) {\n          console.warn('[Webild Visual Editor] Failed to apply change:', err);\n        }\n      });\n\n      window.parent.postMessage({\n        type: 'webild-changes-applied',\n        data: { count: changes.length }\n      }, '*');\n\n      return;\n    }\n\n    if (e.data.type === 'webild-replace-image') {\n      console.log('[Webild Visual Editor] Received image replace request:', e.data.data);\n      const { selector, newSrc, isBackground } = e.data.data;\n      const element = document.querySelector(selector);\n\n      if (element) {\n        let oldSrc = '';\n\n        if (isBackground) {\n          const style = window.getComputedStyle(element);\n          const bgImage = style.backgroundImage;\n          if (bgImage && bgImage !== 'none') {\n            const urlMatch = bgImage.match(/url\\(['\"]?([^'\")]+)['\"]?\\)/);\n            if (urlMatch) {\n              oldSrc = urlMatch[1];\n            }\n          }\n          element.style.backgroundImage = `url('${newSrc}')`;\n\n          // Track this change\n          const changeData = {\n            selector: getUniqueSelector(element),\n            type: 'backgroundImage',\n            oldValue: oldSrc,\n            newValue: newSrc,\n            src: newSrc\n          };\n          actualChanges.push(changeData);\n          console.log('[Webild Visual Editor] Background image change tracked:', changeData);\n        } else if (element.tagName === 'IMG') {\n          // Get the original src attribute value (not the resolved URL)\n          oldSrc = element.getAttribute('src') || element.src;\n          element.src = newSrc;\n          element.setAttribute('src', newSrc);\n\n          // Track this change\n          const changeData = {\n            selector: getUniqueSelector(element),\n            type: 'image',\n            oldValue: oldSrc,\n            newValue: newSrc,\n            src: newSrc,\n            alt: element.alt\n          };\n          actualChanges.push(changeData);\n          console.log('[Webild Visual Editor] Image change tracked:', changeData);\n          console.log('[Webild Visual Editor] Total changes now:', actualChanges.length);\n        }\n\n        window.parent.postMessage({\n          type: 'webild-image-replaced',\n          data: { selector, newSrc, oldSrc }\n        }, '*');\n      } else {\n        console.warn('[Webild Visual Editor] Element not found for selector:', selector);\n      }\n    }\n\n    // Handle element deletion\n    if (e.data.type === 'webild-delete-element') {\n      const { selector } = e.data.data;\n      const element = document.querySelector(selector);\n\n      if (element) {\n        // Get the parent element and identify which child to delete\n        const parent = element.parentElement;\n        const childIndex = Array.from(parent.children).indexOf(element);\n\n        // Get a simplified identifier for the element\n        const elementInfo = {\n          tagName: element.tagName.toLowerCase(),\n          id: element.id,\n          className: element.className,\n          parentSelector: getUniqueSelector(parent),\n          childIndex: childIndex,\n          dataSection: element.getAttribute('data-section'),\n        };\n\n        element.remove();\n\n        // Track this deletion with simplified info\n        actualChanges.push({\n          selector: selector,\n          type: 'delete',\n          oldValue: JSON.stringify(elementInfo),\n          newValue: '',\n        });\n\n        console.log('[Webild Visual Editor] Element deleted:', selector, elementInfo);\n\n        window.parent.postMessage({\n          type: 'webild-element-deleted',\n          data: { selector, elementInfo }\n        }, '*');\n      }\n    }\n\n    // Handle cancel/reset - reload the page to discard all changes\n    if (e.data.type === 'webild-cancel-changes') {\n      console.log('[Webild Visual Editor] Canceling changes and reloading...');\n      // Clear all tracked changes\n      actualChanges.length = 0;\n      // Reload the page to discard all local changes\n      window.location.reload();\n    }\n  };\n\n  // Attach event listeners immediately (they check isActive flag)\n  document.addEventListener('mouseover', handleMouseOver, true);\n  document.addEventListener('mouseout', handleMouseOut, true);\n  document.addEventListener('click', handleClick, true);\n  document.addEventListener('keydown', handleKeyDown, true);\n  document.addEventListener('blur', handleBlur, true);\n  window.addEventListener('scroll', handleScroll, true);\n  window.addEventListener('message', handleMessage, true);\n\n  window.webildCleanup = () => {\n    isActive = false;\n    \n    if (selectedElement) {\n      makeUneditable(selectedElement, false);\n    }\n    \n    removeHoverOverlay();\n    \n    document.removeEventListener('mouseover', handleMouseOver, true);\n    document.removeEventListener('mouseout', handleMouseOut, true);\n    document.removeEventListener('click', handleClick, true);\n    document.removeEventListener('keydown', handleKeyDown, true);\n    document.removeEventListener('blur', handleBlur, true);\n    window.removeEventListener('scroll', handleScroll, true);\n    window.removeEventListener('message', handleMessage, true);\n    \n    document.querySelectorAll('.' + hoverClass).forEach(el => {\n      el.classList.remove(hoverClass);\n    });\n    document.querySelectorAll('.' + selectedClass).forEach(el => {\n      el.classList.remove(selectedClass);\n    });\n    \n    const styleEl = document.getElementById('webild-inspector-styles');\n    if (styleEl) styleEl.remove();\n    \n    hoveredElement = null;\n    selectedElement = null;\n  };\n\n  // Send ready signal to parent\n  window.parent.postMessage({ type: 'webild-editor-ready' }, '*');\n  console.log('[Webild Visual Editor] Ready and waiting for activation');\n})();\n",
          }}
        />
</body>
    </html>
  );
}